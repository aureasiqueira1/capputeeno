{"version":3,"names":["buildTemplate","template","statement","buildExportAll","MISSING_PLUGIN_WARNING","MISSING_PLUGIN_ERROR","getExportSpecifierName","node","stringSpecifiers","type","name","stringValue","value","isIdentifierName","add","Error","constructExportCall","path","exportIdent","exportNames","exportValues","exportStarTarget","statements","length","push","t","expressionStatement","callExpression","stringLiteral","objectProperties","i","exportName","exportValue","objectProperty","has","identifier","objectExpression","exportObj","scope","generateUid","variableDeclaration","variableDeclarator","KEY","generateUidIdentifier","EXPORT_OBJ","TARGET","assignmentExpression","memberExpression","declare","api","options","assertVersion","systemGlobal","allowTopLevelThis","reassignmentVisited","WeakSet","reassignmentVisitor","arg","isAssignmentExpression","get","isObjectPattern","isArrayPattern","exprs","Object","keys","getBindingIdentifiers","getBinding","exportedNames","exports","exportedName","buildCall","expression","replaceWith","sequenceExpression","isIdentifier","isPostUpdateExpression","isUpdateExpression","prefix","binaryExpression","operator","unaryExpression","cloneNode","argument","numericLiteral","pre","file","set","visitor","CallExpression","state","isImport","callee","console","warn","buildDynamicImport","specifier","contextIdent","MetaProperty","meta","property","ReferencedIdentifier","hasBinding","Program","enter","Set","rewriteThis","exit","exportMap","create","modules","beforeBody","setters","sources","variableIds","removedPaths","addExportName","key","val","pushModule","source","specifiers","module","forEach","m","imports","concat","buildExportCall","body","isFunctionDeclaration","isClassDeclaration","id","toExpression","isVariableDeclaration","kind","isImportDeclaration","removeBinding","remove","isExportAllDeclaration","isExportDefaultDeclaration","declar","declaration","buildUndefinedNode","isExportNamedDeclaration","isFunction","isClass","nodes","local","exported","binding","replaceWithMultiple","setterBody","target","isImportNamespaceSpecifier","isImportDefaultSpecifier","importSpecifier","isImportSpecifier","imported","hasExportStar","isExportSpecifier","isStringLiteral","functionExpression","blockStatement","moduleName","getModuleName","opts","hoistVariables","hasInit","unshift","map","traverse","hasTLA","AwaitExpression","stop","Function","skip","noScope","SYSTEM_REGISTER","BEFORE_BODY","MODULE_NAME","SETTERS","arrayExpression","EXECUTE","SOURCES","EXPORT_IDENTIFIER","CONTEXT_IDENTIFIER"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport hoistVariables from \"@babel/helper-hoist-variables\";\nimport { template, types as t } from \"@babel/core\";\nimport {\n  buildDynamicImport,\n  getModuleName,\n  rewriteThis,\n} from \"@babel/helper-module-transforms\";\nimport type { PluginOptions } from \"@babel/helper-module-transforms\";\nimport { isIdentifierName } from \"@babel/helper-validator-identifier\";\nimport type { NodePath, Scope, Visitor } from \"@babel/traverse\";\n\nconst buildTemplate = template.statement(`\n  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {\n    \"use strict\";\n    BEFORE_BODY;\n    return {\n      setters: SETTERS,\n      execute: EXECUTE,\n    };\n  });\n`);\n\nconst buildExportAll = template.statement(`\n  for (var KEY in TARGET) {\n    if (KEY !== \"default\" && KEY !== \"__esModule\") EXPORT_OBJ[KEY] = TARGET[KEY];\n  }\n`);\n\nconst MISSING_PLUGIN_WARNING = `\\\nWARNING: Dynamic import() transformation must be enabled using the\n         @babel/plugin-proposal-dynamic-import plugin. Babel 8 will\n         no longer transform import() without using that plugin.\n`;\n\nconst MISSING_PLUGIN_ERROR = `\\\nERROR: Dynamic import() transformation must be enabled using the\n       @babel/plugin-proposal-dynamic-import plugin. Babel 8\n       no longer transforms import() without using that plugin.\n`;\n\n//todo: use getExportSpecifierName in `helper-module-transforms` when this library is refactored to NodePath usage.\n\nexport function getExportSpecifierName(\n  node: t.Node,\n  stringSpecifiers: Set<string>,\n): string {\n  if (node.type === \"Identifier\") {\n    return node.name;\n  } else if (node.type === \"StringLiteral\") {\n    const stringValue = node.value;\n    // add specifier value to `stringSpecifiers` only when it can not be converted to an identifier name\n    // i.e In `import { \"foo\" as bar }`\n    // we do not consider `\"foo\"` to be a `stringSpecifier` because we can treat it as\n    // `import { foo as bar }`\n    // This helps minimize the size of `stringSpecifiers` and reduce overhead of checking valid identifier names\n    // when building transpiled code from metadata\n    if (!isIdentifierName(stringValue)) {\n      stringSpecifiers.add(stringValue);\n    }\n    return stringValue;\n  } else {\n    throw new Error(\n      `Expected export specifier to be either Identifier or StringLiteral, got ${node.type}`,\n    );\n  }\n}\n\ntype PluginState = {\n  contextIdent: string;\n  // List of names that should only be printed as string literals.\n  // i.e. `import { \"any unicode\" as foo } from \"some-module\"`\n  // `stringSpecifiers` is Set(1) [\"any unicode\"]\n  // In most cases `stringSpecifiers` is an empty Set\n  stringSpecifiers: Set<string>;\n};\n\ntype ModuleMetadata = {\n  key: string;\n  imports: any[];\n  exports: any[];\n};\n\nfunction constructExportCall(\n  path: NodePath